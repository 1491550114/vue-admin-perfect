// ../common/src/ast.ts
import { parse, walkIdentifiers } from "@vue/compiler-sfc";
var parseSFC = (code, id) => {
  const { descriptor } = parse(code, {
    filename: id
  });
  return descriptor;
};
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, scriptSetup) {
  if (!node)
    return;
  walkIdentifiers(node, (id) => {
    if (Object.keys(scriptSetup.bindings).includes(id.name) && !Object.keys(scriptSetup.imports).includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function.`
      );
  });
}

// ../common/src/constants.ts
var DEFINE_OPTIONS = "defineOptions";

// src/core/utils.ts
var filterMarco = (scriptSetup) => {
  return scriptSetup.scriptSetupAst.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    return isCallOf(node, DEFINE_OPTIONS) ? node : void 0;
  }).filter((node) => !!node);
};
var hasPropsOrEmits = (node) => node.properties.some(
  (prop) => (prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier" && (prop.key.name === "props" || prop.key.name === "emits")
);

export {
  parseSFC,
  checkInvalidScopeReference,
  DEFINE_OPTIONS,
  filterMarco,
  hasPropsOrEmits
};
