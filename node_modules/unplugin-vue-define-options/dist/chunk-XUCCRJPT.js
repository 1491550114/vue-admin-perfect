"use strict";Object.defineProperty(exports, "__esModule", {value: true});





var _chunkCX55I6BEjs = require('./chunk-CX55I6BE.js');

// src/core/transform.ts
var _compilersfc = require('@vue/compiler-sfc');
var transform = (code, id, s = new (0, _compilersfc.MagicString)(code)) => {
  if (!code.includes(_chunkCX55I6BEjs.DEFINE_OPTIONS))
    return;
  const sfc = _chunkCX55I6BEjs.parseSFC.call(void 0, code, id);
  if (!sfc.scriptSetup)
    return;
  if (!sfc.scriptSetup.scriptSetupAst) {
    sfc.scriptSetup = _compilersfc.compileScript.call(void 0, sfc, {
      id
    });
  }
  const { script, scriptSetup } = sfc;
  const startOffset = scriptSetup.loc.start.offset;
  const nodes = _chunkCX55I6BEjs.filterMarco.call(void 0, scriptSetup);
  if (nodes.length === 0)
    return;
  else if (nodes.length > 1)
    throw new SyntaxError(`duplicate ${_chunkCX55I6BEjs.DEFINE_OPTIONS}() call`);
  if (script)
    throw new SyntaxError(
      `${_chunkCX55I6BEjs.DEFINE_OPTIONS} cannot be used, with both script and <script setup>.`
    );
  const [node] = nodes;
  const [arg] = node.arguments;
  if (!(node.arguments.length === 1 && arg.type === "ObjectExpression")) {
    throw new SyntaxError(`${_chunkCX55I6BEjs.DEFINE_OPTIONS}() arguments error`);
  }
  if (_chunkCX55I6BEjs.hasPropsOrEmits.call(void 0, arg)) {
    throw new SyntaxError(
      `${_chunkCX55I6BEjs.DEFINE_OPTIONS}() please use defineProps or defineEmits instead.`
    );
  }
  _chunkCX55I6BEjs.checkInvalidScopeReference.call(void 0, arg, _chunkCX55I6BEjs.DEFINE_OPTIONS, scriptSetup);
  const argText = code.slice(startOffset + arg.start, startOffset + arg.end);
  const lang = scriptSetup.attrs.lang ? ` lang="${scriptSetup.attrs.lang}"` : "";
  s.prepend(
    `<script${lang}>
import { defineComponent as DO_defineComponent } from 'vue';
export default /*#__PURE__*/ DO_defineComponent(${argText});
<\/script>
`
  );
  s.remove(startOffset + node.start, startOffset + node.end);
  return s;
};



exports.transform = transform;
