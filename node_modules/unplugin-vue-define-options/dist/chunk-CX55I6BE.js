"use strict";Object.defineProperty(exports, "__esModule", {value: true});// ../common/src/ast.ts
var _compilersfc = require('@vue/compiler-sfc');
var parseSFC = (code, id) => {
  const { descriptor } = _compilersfc.parse.call(void 0, code, {
    filename: id
  });
  return descriptor;
};
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, scriptSetup) {
  if (!node)
    return;
  _compilersfc.walkIdentifiers.call(void 0, node, (id) => {
    if (Object.keys(scriptSetup.bindings).includes(id.name) && !Object.keys(scriptSetup.imports).includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function.`
      );
  });
}

// ../common/src/constants.ts
var DEFINE_OPTIONS = "defineOptions";

// src/core/utils.ts
var filterMarco = (scriptSetup) => {
  return scriptSetup.scriptSetupAst.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    return isCallOf(node, DEFINE_OPTIONS) ? node : void 0;
  }).filter((node) => !!node);
};
var hasPropsOrEmits = (node) => node.properties.some(
  (prop) => (prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier" && (prop.key.name === "props" || prop.key.name === "emits")
);







exports.parseSFC = parseSFC; exports.checkInvalidScopeReference = checkInvalidScopeReference; exports.DEFINE_OPTIONS = DEFINE_OPTIONS; exports.filterMarco = filterMarco; exports.hasPropsOrEmits = hasPropsOrEmits;
